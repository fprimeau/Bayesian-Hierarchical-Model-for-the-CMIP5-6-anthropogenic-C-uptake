
// Code generated by stanc 47f0efd
#include <stan/model/model_header.hpp>
namespace cmip_model_namespace {

using stan::model::model_base_crtp;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 89> locations_array__ = 
{" (found before start of program)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 42, column 4 to column 25)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 43, column 4 to column 25)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 44, column 4 to column 25)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 45, column 4 to column 25)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 46, column 4 to column 19)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 47, column 4 to column 19)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 48, column 4 to column 21)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 49, column 4 to column 23)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 50, column 4 to column 23)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 51, column 4 to column 23)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 52, column 4 to column 23)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 53, column 4 to column 23)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 54, column 4 to column 23)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 55, column 4 to column 23)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 56, column 4 to column 23)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 57, column 4 to column 20)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 58, column 4 to column 20)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 61, column 4 to column 28)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 62, column 4 to column 28)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 63, column 4 to column 28)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 64, column 4 to column 28)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 69, column 4 to column 83)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 70, column 4 to column 83)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 71, column 4 to column 45)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 72, column 4 to column 45)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 73, column 4 to column 48)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 74, column 4 to column 48)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 75, column 4 to column 48)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 76, column 4 to column 48)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 77, column 4 to column 48)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 78, column 4 to column 48)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 79, column 4 to column 48)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 80, column 4 to column 48)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 81, column 4 to column 45)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 82, column 4 to column 45)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 83, column 4 to column 52)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 86, column 4 to column 121)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 89, column 4 to column 131)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 92, column 4 to column 121)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 95, column 4 to column 132)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 98, column 4 to column 73)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 101, column 4 to column 70)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 10, column 4 to column 21)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 11, column 22 to column 25)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 11, column 4 to column 27)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 13, column 4 to column 21)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 14, column 11 to column 14)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 14, column 4 to column 20)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 15, column 11 to column 14)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 15, column 4 to column 22)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 16, column 11 to column 14)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 16, column 4 to column 20)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 20, column 4 to column 21)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 21, column 22 to column 25)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 21, column 4 to column 27)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 23, column 4 to column 21)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 24, column 11 to column 14)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 24, column 4 to column 20)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 25, column 11 to column 14)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 25, column 4 to column 22)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 26, column 11 to column 14)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 26, column 4 to column 20)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 31, column 4 to column 20)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 32, column 11 to column 13)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 32, column 4 to column 18)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 33, column 11 to column 13)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 33, column 4 to column 20)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 34, column 11 to column 13)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 34, column 4 to column 18)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 36, column 4 to column 20)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 37, column 11 to column 13)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 37, column 4 to column 18)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 38, column 11 to column 13)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 38, column 4 to column 20)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 39, column 11 to column 13)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 39, column 4 to column 18)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 49, column 11 to column 14)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 50, column 11 to column 14)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 51, column 11 to column 14)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 52, column 11 to column 14)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 53, column 11 to column 14)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 54, column 11 to column 14)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 55, column 11 to column 14)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 56, column 11 to column 14)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 57, column 11 to column 13)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 58, column 11 to column 13)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 4, column 8 to column 67)",
 " (in '/Users/fprimeau/RESEARCH/Bayesian-Hierarchical-Model-for-the-CMIP5-6-anthropogenic-C-uptake/src/tmp/cmip.stan', line 3, column 50 to line 5, column 5)"};

struct se_lpdf_functor__ {
  template <bool propto__, typename T0__, typename T1__, typename T2__,
            stan::require_all_t<stan::is_col_vector<T0__>,
                                stan::is_vt_not_complex<T0__>,
                                stan::is_col_vector<T1__>,
                                stan::is_vt_not_complex<T1__>,
                                stan::is_stan_scalar<T2__>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T1__>, T2__>
  operator()(const T0__& std, const T1__& n, const T2__& sig,
             std::ostream* pstream__) const;
};

template <bool propto__, typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>,
                              stan::is_stan_scalar<T2__>>* = nullptr>
  stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T1__>, T2__>
  se_lpdf(const T0__& std_arg__, const T1__& n_arg__, const T2__& sig,
          std::ostream* pstream__) {
    using local_scalar_t__ =
            stan::promote_args_t<stan::base_type_t<T0__>,
                                 stan::base_type_t<T1__>, T2__>;
    int current_statement__ = 0; 
    const auto& std = stan::math::to_ref(std_arg__);
    const auto& n = stan::math::to_ref(n_arg__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      current_statement__ = 87;
      return ((-stan::math::sum(stan::math::add(n, 1)) *
                stan::math::log(sig)) -
               ((0.5 *
                  stan::math::sum(
                    stan::math::elt_multiply(
                      stan::math::elt_multiply(n, std), std))) / (sig * sig)));
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    }
template <bool propto__, typename T0__, typename T1__, typename T2__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>,
                              stan::is_col_vector<T1__>,
                              stan::is_vt_not_complex<T1__>,
                              stan::is_stan_scalar<T2__>>*>
stan::promote_args_t<stan::base_type_t<T0__>, stan::base_type_t<T1__>, T2__>
se_lpdf_functor__::operator()(const T0__& std, const T1__& n,
                              const T2__& sig, std::ostream* pstream__) 
const
{
  return se_lpdf<propto__>(std, n, sig, pstream__);
}

 class cmip_model final : public model_base_crtp<cmip_model> {

 private:
  int N1a;
  std::vector<double> d1a;
  int N1b;
  Eigen::Matrix<double, -1, 1> d1b__;
  Eigen::Matrix<double, -1, 1> sig1b__;
  Eigen::Matrix<double, -1, 1> n1b__;
  int N2a;
  std::vector<double> d2a;
  int N2b;
  Eigen::Matrix<double, -1, 1> d2b__;
  Eigen::Matrix<double, -1, 1> sig2b__;
  Eigen::Matrix<double, -1, 1> n2b__;
  int N3;
  Eigen::Matrix<double, -1, 1> d3__;
  Eigen::Matrix<double, -1, 1> sig3__;
  Eigen::Matrix<double, -1, 1> n3__;
  int N4;
  Eigen::Matrix<double, -1, 1> d4__;
  Eigen::Matrix<double, -1, 1> sig4__;
  Eigen::Matrix<double, -1, 1> n4__; 
  Eigen::Map<Eigen::Matrix<double, -1, 1>> d1b{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> sig1b{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> n1b{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> d2b{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> sig2b{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> n2b{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> d3{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> sig3{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> n3{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> d4{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> sig4{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, 1>> n4{nullptr, 0};
 
 public:
  ~cmip_model() { }
  
  inline std::string model_name() const final { return "cmip_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = stanc3 47f0efd", "stancflags = "};
  }
  
  
  cmip_model(stan::io::var_context& context__,
             unsigned int random_seed__ = 0,
             std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "cmip_model_namespace::cmip_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 43;
      context__.validate_dims("data initialization","N1a","int",
           std::vector<size_t>{});
      N1a = std::numeric_limits<int>::min();
      
      
      current_statement__ = 43;
      N1a = context__.vals_i("N1a")[(1 - 1)];
      current_statement__ = 43;
      stan::math::check_greater_or_equal(function__, "N1a", N1a, 0);
      current_statement__ = 44;
      stan::math::validate_non_negative_index("d1a", "N1a", N1a);
      current_statement__ = 45;
      context__.validate_dims("data initialization","d1a","double",
           std::vector<size_t>{static_cast<size_t>(N1a)});
      d1a = 
        std::vector<double>(N1a, std::numeric_limits<double>::quiet_NaN());
      
      
      current_statement__ = 45;
      d1a = context__.vals_r("d1a");
      current_statement__ = 45;
      stan::math::check_greater_or_equal(function__, "d1a", d1a, 0);
      current_statement__ = 46;
      context__.validate_dims("data initialization","N1b","int",
           std::vector<size_t>{});
      N1b = std::numeric_limits<int>::min();
      
      
      current_statement__ = 46;
      N1b = context__.vals_i("N1b")[(1 - 1)];
      current_statement__ = 46;
      stan::math::check_greater_or_equal(function__, "N1b", N1b, 0);
      current_statement__ = 47;
      stan::math::validate_non_negative_index("d1b", "N1b", N1b);
      current_statement__ = 48;
      context__.validate_dims("data initialization","d1b","double",
           std::vector<size_t>{static_cast<size_t>(N1b)});
      d1b__ = 
        Eigen::Matrix<double, -1, 1>::Constant(N1b,
          std::numeric_limits<double>::quiet_NaN());
      new (&d1b) Eigen::Map<Eigen::Matrix<double, -1, 1>>(d1b__.data(), N1b);
      
      {
        std::vector<local_scalar_t__> d1b_flat__;
        current_statement__ = 48;
        d1b_flat__ = context__.vals_r("d1b");
        current_statement__ = 48;
        pos__ = 1;
        current_statement__ = 48;
        for (int sym1__ = 1; sym1__ <= N1b; ++sym1__) {
          current_statement__ = 48;
          stan::model::assign(d1b, d1b_flat__[(pos__ - 1)],
            "assigning variable d1b", stan::model::index_uni(sym1__));
          current_statement__ = 48;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 49;
      stan::math::validate_non_negative_index("sig1b", "N1b", N1b);
      current_statement__ = 50;
      context__.validate_dims("data initialization","sig1b","double",
           std::vector<size_t>{static_cast<size_t>(N1b)});
      sig1b__ = 
        Eigen::Matrix<double, -1, 1>::Constant(N1b,
          std::numeric_limits<double>::quiet_NaN());
      new (&sig1b) Eigen::Map<Eigen::Matrix<double, -1, 1>>(sig1b__.data(), N1b);
        
      
      {
        std::vector<local_scalar_t__> sig1b_flat__;
        current_statement__ = 50;
        sig1b_flat__ = context__.vals_r("sig1b");
        current_statement__ = 50;
        pos__ = 1;
        current_statement__ = 50;
        for (int sym1__ = 1; sym1__ <= N1b; ++sym1__) {
          current_statement__ = 50;
          stan::model::assign(sig1b, sig1b_flat__[(pos__ - 1)],
            "assigning variable sig1b", stan::model::index_uni(sym1__));
          current_statement__ = 50;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 51;
      stan::math::validate_non_negative_index("n1b", "N1b", N1b);
      current_statement__ = 52;
      context__.validate_dims("data initialization","n1b","double",
           std::vector<size_t>{static_cast<size_t>(N1b)});
      n1b__ = 
        Eigen::Matrix<double, -1, 1>::Constant(N1b,
          std::numeric_limits<double>::quiet_NaN());
      new (&n1b) Eigen::Map<Eigen::Matrix<double, -1, 1>>(n1b__.data(), N1b);
      
      {
        std::vector<local_scalar_t__> n1b_flat__;
        current_statement__ = 52;
        n1b_flat__ = context__.vals_r("n1b");
        current_statement__ = 52;
        pos__ = 1;
        current_statement__ = 52;
        for (int sym1__ = 1; sym1__ <= N1b; ++sym1__) {
          current_statement__ = 52;
          stan::model::assign(n1b, n1b_flat__[(pos__ - 1)],
            "assigning variable n1b", stan::model::index_uni(sym1__));
          current_statement__ = 52;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 53;
      context__.validate_dims("data initialization","N2a","int",
           std::vector<size_t>{});
      N2a = std::numeric_limits<int>::min();
      
      
      current_statement__ = 53;
      N2a = context__.vals_i("N2a")[(1 - 1)];
      current_statement__ = 53;
      stan::math::check_greater_or_equal(function__, "N2a", N2a, 0);
      current_statement__ = 54;
      stan::math::validate_non_negative_index("d2a", "N2a", N2a);
      current_statement__ = 55;
      context__.validate_dims("data initialization","d2a","double",
           std::vector<size_t>{static_cast<size_t>(N2a)});
      d2a = 
        std::vector<double>(N2a, std::numeric_limits<double>::quiet_NaN());
      
      
      current_statement__ = 55;
      d2a = context__.vals_r("d2a");
      current_statement__ = 55;
      stan::math::check_greater_or_equal(function__, "d2a", d2a, 0);
      current_statement__ = 56;
      context__.validate_dims("data initialization","N2b","int",
           std::vector<size_t>{});
      N2b = std::numeric_limits<int>::min();
      
      
      current_statement__ = 56;
      N2b = context__.vals_i("N2b")[(1 - 1)];
      current_statement__ = 56;
      stan::math::check_greater_or_equal(function__, "N2b", N2b, 0);
      current_statement__ = 57;
      stan::math::validate_non_negative_index("d2b", "N2b", N2b);
      current_statement__ = 58;
      context__.validate_dims("data initialization","d2b","double",
           std::vector<size_t>{static_cast<size_t>(N2b)});
      d2b__ = 
        Eigen::Matrix<double, -1, 1>::Constant(N2b,
          std::numeric_limits<double>::quiet_NaN());
      new (&d2b) Eigen::Map<Eigen::Matrix<double, -1, 1>>(d2b__.data(), N2b);
      
      {
        std::vector<local_scalar_t__> d2b_flat__;
        current_statement__ = 58;
        d2b_flat__ = context__.vals_r("d2b");
        current_statement__ = 58;
        pos__ = 1;
        current_statement__ = 58;
        for (int sym1__ = 1; sym1__ <= N2b; ++sym1__) {
          current_statement__ = 58;
          stan::model::assign(d2b, d2b_flat__[(pos__ - 1)],
            "assigning variable d2b", stan::model::index_uni(sym1__));
          current_statement__ = 58;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 59;
      stan::math::validate_non_negative_index("sig2b", "N2b", N2b);
      current_statement__ = 60;
      context__.validate_dims("data initialization","sig2b","double",
           std::vector<size_t>{static_cast<size_t>(N2b)});
      sig2b__ = 
        Eigen::Matrix<double, -1, 1>::Constant(N2b,
          std::numeric_limits<double>::quiet_NaN());
      new (&sig2b) Eigen::Map<Eigen::Matrix<double, -1, 1>>(sig2b__.data(), N2b);
        
      
      {
        std::vector<local_scalar_t__> sig2b_flat__;
        current_statement__ = 60;
        sig2b_flat__ = context__.vals_r("sig2b");
        current_statement__ = 60;
        pos__ = 1;
        current_statement__ = 60;
        for (int sym1__ = 1; sym1__ <= N2b; ++sym1__) {
          current_statement__ = 60;
          stan::model::assign(sig2b, sig2b_flat__[(pos__ - 1)],
            "assigning variable sig2b", stan::model::index_uni(sym1__));
          current_statement__ = 60;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 61;
      stan::math::validate_non_negative_index("n2b", "N2b", N2b);
      current_statement__ = 62;
      context__.validate_dims("data initialization","n2b","double",
           std::vector<size_t>{static_cast<size_t>(N2b)});
      n2b__ = 
        Eigen::Matrix<double, -1, 1>::Constant(N2b,
          std::numeric_limits<double>::quiet_NaN());
      new (&n2b) Eigen::Map<Eigen::Matrix<double, -1, 1>>(n2b__.data(), N2b);
      
      {
        std::vector<local_scalar_t__> n2b_flat__;
        current_statement__ = 62;
        n2b_flat__ = context__.vals_r("n2b");
        current_statement__ = 62;
        pos__ = 1;
        current_statement__ = 62;
        for (int sym1__ = 1; sym1__ <= N2b; ++sym1__) {
          current_statement__ = 62;
          stan::model::assign(n2b, n2b_flat__[(pos__ - 1)],
            "assigning variable n2b", stan::model::index_uni(sym1__));
          current_statement__ = 62;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 63;
      context__.validate_dims("data initialization","N3","int",
           std::vector<size_t>{});
      N3 = std::numeric_limits<int>::min();
      
      
      current_statement__ = 63;
      N3 = context__.vals_i("N3")[(1 - 1)];
      current_statement__ = 63;
      stan::math::check_greater_or_equal(function__, "N3", N3, 0);
      current_statement__ = 64;
      stan::math::validate_non_negative_index("d3", "N3", N3);
      current_statement__ = 65;
      context__.validate_dims("data initialization","d3","double",
           std::vector<size_t>{static_cast<size_t>(N3)});
      d3__ = 
        Eigen::Matrix<double, -1, 1>::Constant(N3,
          std::numeric_limits<double>::quiet_NaN());
      new (&d3) Eigen::Map<Eigen::Matrix<double, -1, 1>>(d3__.data(), N3);
      
      {
        std::vector<local_scalar_t__> d3_flat__;
        current_statement__ = 65;
        d3_flat__ = context__.vals_r("d3");
        current_statement__ = 65;
        pos__ = 1;
        current_statement__ = 65;
        for (int sym1__ = 1; sym1__ <= N3; ++sym1__) {
          current_statement__ = 65;
          stan::model::assign(d3, d3_flat__[(pos__ - 1)],
            "assigning variable d3", stan::model::index_uni(sym1__));
          current_statement__ = 65;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 66;
      stan::math::validate_non_negative_index("sig3", "N3", N3);
      current_statement__ = 67;
      context__.validate_dims("data initialization","sig3","double",
           std::vector<size_t>{static_cast<size_t>(N3)});
      sig3__ = 
        Eigen::Matrix<double, -1, 1>::Constant(N3,
          std::numeric_limits<double>::quiet_NaN());
      new (&sig3) Eigen::Map<Eigen::Matrix<double, -1, 1>>(sig3__.data(), N3);
      
      {
        std::vector<local_scalar_t__> sig3_flat__;
        current_statement__ = 67;
        sig3_flat__ = context__.vals_r("sig3");
        current_statement__ = 67;
        pos__ = 1;
        current_statement__ = 67;
        for (int sym1__ = 1; sym1__ <= N3; ++sym1__) {
          current_statement__ = 67;
          stan::model::assign(sig3, sig3_flat__[(pos__ - 1)],
            "assigning variable sig3", stan::model::index_uni(sym1__));
          current_statement__ = 67;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 68;
      stan::math::validate_non_negative_index("n3", "N3", N3);
      current_statement__ = 69;
      context__.validate_dims("data initialization","n3","double",
           std::vector<size_t>{static_cast<size_t>(N3)});
      n3__ = 
        Eigen::Matrix<double, -1, 1>::Constant(N3,
          std::numeric_limits<double>::quiet_NaN());
      new (&n3) Eigen::Map<Eigen::Matrix<double, -1, 1>>(n3__.data(), N3);
      
      {
        std::vector<local_scalar_t__> n3_flat__;
        current_statement__ = 69;
        n3_flat__ = context__.vals_r("n3");
        current_statement__ = 69;
        pos__ = 1;
        current_statement__ = 69;
        for (int sym1__ = 1; sym1__ <= N3; ++sym1__) {
          current_statement__ = 69;
          stan::model::assign(n3, n3_flat__[(pos__ - 1)],
            "assigning variable n3", stan::model::index_uni(sym1__));
          current_statement__ = 69;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 70;
      context__.validate_dims("data initialization","N4","int",
           std::vector<size_t>{});
      N4 = std::numeric_limits<int>::min();
      
      
      current_statement__ = 70;
      N4 = context__.vals_i("N4")[(1 - 1)];
      current_statement__ = 70;
      stan::math::check_greater_or_equal(function__, "N4", N4, 0);
      current_statement__ = 71;
      stan::math::validate_non_negative_index("d4", "N4", N4);
      current_statement__ = 72;
      context__.validate_dims("data initialization","d4","double",
           std::vector<size_t>{static_cast<size_t>(N4)});
      d4__ = 
        Eigen::Matrix<double, -1, 1>::Constant(N4,
          std::numeric_limits<double>::quiet_NaN());
      new (&d4) Eigen::Map<Eigen::Matrix<double, -1, 1>>(d4__.data(), N4);
      
      {
        std::vector<local_scalar_t__> d4_flat__;
        current_statement__ = 72;
        d4_flat__ = context__.vals_r("d4");
        current_statement__ = 72;
        pos__ = 1;
        current_statement__ = 72;
        for (int sym1__ = 1; sym1__ <= N4; ++sym1__) {
          current_statement__ = 72;
          stan::model::assign(d4, d4_flat__[(pos__ - 1)],
            "assigning variable d4", stan::model::index_uni(sym1__));
          current_statement__ = 72;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 73;
      stan::math::validate_non_negative_index("sig4", "N4", N4);
      current_statement__ = 74;
      context__.validate_dims("data initialization","sig4","double",
           std::vector<size_t>{static_cast<size_t>(N4)});
      sig4__ = 
        Eigen::Matrix<double, -1, 1>::Constant(N4,
          std::numeric_limits<double>::quiet_NaN());
      new (&sig4) Eigen::Map<Eigen::Matrix<double, -1, 1>>(sig4__.data(), N4);
      
      {
        std::vector<local_scalar_t__> sig4_flat__;
        current_statement__ = 74;
        sig4_flat__ = context__.vals_r("sig4");
        current_statement__ = 74;
        pos__ = 1;
        current_statement__ = 74;
        for (int sym1__ = 1; sym1__ <= N4; ++sym1__) {
          current_statement__ = 74;
          stan::model::assign(sig4, sig4_flat__[(pos__ - 1)],
            "assigning variable sig4", stan::model::index_uni(sym1__));
          current_statement__ = 74;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 75;
      stan::math::validate_non_negative_index("n4", "N4", N4);
      current_statement__ = 76;
      context__.validate_dims("data initialization","n4","double",
           std::vector<size_t>{static_cast<size_t>(N4)});
      n4__ = 
        Eigen::Matrix<double, -1, 1>::Constant(N4,
          std::numeric_limits<double>::quiet_NaN());
      new (&n4) Eigen::Map<Eigen::Matrix<double, -1, 1>>(n4__.data(), N4);
      
      {
        std::vector<local_scalar_t__> n4_flat__;
        current_statement__ = 76;
        n4_flat__ = context__.vals_r("n4");
        current_statement__ = 76;
        pos__ = 1;
        current_statement__ = 76;
        for (int sym1__ = 1; sym1__ <= N4; ++sym1__) {
          current_statement__ = 76;
          stan::model::assign(n4, n4_flat__[(pos__ - 1)],
            "assigning variable n4", stan::model::index_uni(sym1__));
          current_statement__ = 76;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 77;
      stan::math::validate_non_negative_index("dX1a_a", "N1a", N1a);
      current_statement__ = 78;
      stan::math::validate_non_negative_index("dX1n_a", "N1a", N1a);
      current_statement__ = 79;
      stan::math::validate_non_negative_index("dX1a_b", "N1b", N1b);
      current_statement__ = 80;
      stan::math::validate_non_negative_index("dX1n_b", "N1b", N1b);
      current_statement__ = 81;
      stan::math::validate_non_negative_index("dX2a_a", "N2a", N2a);
      current_statement__ = 82;
      stan::math::validate_non_negative_index("dX2n_a", "N2a", N2a);
      current_statement__ = 83;
      stan::math::validate_non_negative_index("dX2a_b", "N2b", N2b);
      current_statement__ = 84;
      stan::math::validate_non_negative_index("dX2n_b", "N2b", N2b);
      current_statement__ = 85;
      stan::math::validate_non_negative_index("dX3a", "N3", N3);
      current_statement__ = 86;
      stan::math::validate_non_negative_index("dX4n", "N4", N4);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + 1 + 1 + 1 + 1 + 1 + 1 + N1a + N1a + N1b + N1b + 
      N2a + N2a + N2b + N2b + N3 + N4;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "cmip_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      local_scalar_t__ sigXMa = DUMMY_VAR__;
      current_statement__ = 1;
      sigXMa = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                 0, lp__);
      local_scalar_t__ sigXMn = DUMMY_VAR__;
      current_statement__ = 2;
      sigXMn = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                 0, lp__);
      local_scalar_t__ sigSMa = DUMMY_VAR__;
      current_statement__ = 3;
      sigSMa = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                 0, lp__);
      local_scalar_t__ sigSMn = DUMMY_VAR__;
      current_statement__ = 4;
      sigSMn = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                 0, lp__);
      local_scalar_t__ DeltaCant = DUMMY_VAR__;
      current_statement__ = 5;
      DeltaCant = in__.template read<local_scalar_t__>();
      local_scalar_t__ DeltaCnat = DUMMY_VAR__;
      current_statement__ = 6;
      DeltaCnat = in__.template read<local_scalar_t__>();
      local_scalar_t__ GRDeltaCant = DUMMY_VAR__;
      current_statement__ = 7;
      GRDeltaCant = in__.template read<local_scalar_t__>();
      Eigen::Matrix<local_scalar_t__, -1, 1> dX1a_a =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N1a, DUMMY_VAR__);
      current_statement__ = 8;
      dX1a_a = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                 N1a);
      Eigen::Matrix<local_scalar_t__, -1, 1> dX1n_a =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N1a, DUMMY_VAR__);
      current_statement__ = 9;
      dX1n_a = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                 N1a);
      Eigen::Matrix<local_scalar_t__, -1, 1> dX1a_b =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N1b, DUMMY_VAR__);
      current_statement__ = 10;
      dX1a_b = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                 N1b);
      Eigen::Matrix<local_scalar_t__, -1, 1> dX1n_b =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N1b, DUMMY_VAR__);
      current_statement__ = 11;
      dX1n_b = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                 N1b);
      Eigen::Matrix<local_scalar_t__, -1, 1> dX2a_a =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N2a, DUMMY_VAR__);
      current_statement__ = 12;
      dX2a_a = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                 N2a);
      Eigen::Matrix<local_scalar_t__, -1, 1> dX2n_a =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N2a, DUMMY_VAR__);
      current_statement__ = 13;
      dX2n_a = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                 N2a);
      Eigen::Matrix<local_scalar_t__, -1, 1> dX2a_b =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N2b, DUMMY_VAR__);
      current_statement__ = 14;
      dX2a_b = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                 N2b);
      Eigen::Matrix<local_scalar_t__, -1, 1> dX2n_b =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N2b, DUMMY_VAR__);
      current_statement__ = 15;
      dX2n_b = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                 N2b);
      Eigen::Matrix<local_scalar_t__, -1, 1> dX3a =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N3, DUMMY_VAR__);
      current_statement__ = 16;
      dX3a = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(N3);
      Eigen::Matrix<local_scalar_t__, -1, 1> dX4n =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N4, DUMMY_VAR__);
      current_statement__ = 17;
      dX4n = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(N4);
      {
        current_statement__ = 18;
        lp_accum__.add(stan::math::log((1 / sigXMa)));
        current_statement__ = 19;
        lp_accum__.add(stan::math::log((1 / sigXMn)));
        current_statement__ = 20;
        lp_accum__.add(stan::math::log((1 / sigSMa)));
        current_statement__ = 21;
        lp_accum__.add(stan::math::log((1 / sigSMn)));
        current_statement__ = 22;
        lp_accum__.add(
          se_lpdf<false>(sig1b, n1b,
            stan::math::sqrt(
              (stan::math::square(sigSMa) + stan::math::square(sigSMn))), pstream__));
        current_statement__ = 23;
        lp_accum__.add(
          se_lpdf<false>(sig2b, n2b,
            stan::math::sqrt(
              (stan::math::square(sigSMa) + stan::math::square(sigSMn))), pstream__));
        current_statement__ = 24;
        lp_accum__.add(se_lpdf<false>(sig3, n3, sigSMa, pstream__));
        current_statement__ = 25;
        lp_accum__.add(se_lpdf<false>(sig4, n4, sigSMn, pstream__));
        current_statement__ = 26;
        lp_accum__.add(stan::math::normal_lpdf<false>(dX1a_a, 0, sigXMa));
        current_statement__ = 27;
        lp_accum__.add(stan::math::normal_lpdf<false>(dX1n_a, 0, sigXMn));
        current_statement__ = 28;
        lp_accum__.add(stan::math::normal_lpdf<false>(dX1a_b, 0, sigXMa));
        current_statement__ = 29;
        lp_accum__.add(stan::math::normal_lpdf<false>(dX1n_b, 0, sigXMn));
        current_statement__ = 30;
        lp_accum__.add(stan::math::normal_lpdf<false>(dX2a_a, 0, sigXMa));
        current_statement__ = 31;
        lp_accum__.add(stan::math::normal_lpdf<false>(dX2n_a, 0, sigXMn));
        current_statement__ = 32;
        lp_accum__.add(stan::math::normal_lpdf<false>(dX2a_b, 0, sigXMa));
        current_statement__ = 33;
        lp_accum__.add(stan::math::normal_lpdf<false>(dX2n_b, 0, sigXMn));
        current_statement__ = 34;
        lp_accum__.add(stan::math::normal_lpdf<false>(dX3a, 0, sigXMa));
        current_statement__ = 35;
        lp_accum__.add(stan::math::normal_lpdf<false>(dX4n, 0, sigXMn));
        current_statement__ = 36;
        lp_accum__.add(stan::math::normal_lpdf<false>(GRDeltaCant, 33.0, 4.0));
        current_statement__ = 37;
        lp_accum__.add(
          stan::math::normal_lpdf<false>(d1a,
            stan::math::subtract(
              stan::math::add((DeltaCant - DeltaCnat), dX1a_a), dX1n_a),
            stan::math::sqrt(
              (stan::math::square(sigSMa) + stan::math::square(sigSMn)))));
        current_statement__ = 38;
        lp_accum__.add(
          stan::math::normal_lpdf<false>(d1b,
            stan::math::add(stan::math::add((DeltaCant - DeltaCnat), dX1a_b),
              dX1n_b),
            stan::math::elt_divide(
              stan::math::sqrt(
                (stan::math::square(sigSMa) + stan::math::square(sigSMn))),
              stan::math::sqrt(n1b))));
        current_statement__ = 39;
        lp_accum__.add(
          stan::math::normal_lpdf<false>(d2a,
            stan::math::add(stan::math::add((DeltaCant - DeltaCnat), dX2a_a),
              dX2n_a),
            stan::math::sqrt(
              (stan::math::square(sigSMa) + stan::math::square(sigSMn)))));
        current_statement__ = 40;
        lp_accum__.add(
          stan::math::normal_lpdf<false>(d2b,
            stan::math::add(stan::math::add((DeltaCant - DeltaCnat), dX2a_b),
              dX2n_b),
            stan::math::elt_divide(
              stan::math::sqrt(
                (stan::math::square(sigSMa) + stan::math::square(sigSMn))),
              stan::math::sqrt(n2b))));
        current_statement__ = 41;
        lp_accum__.add(
          stan::math::normal_lpdf<false>(d3,
            stan::math::add(DeltaCant, dX3a),
            stan::math::elt_divide(sigSMa, stan::math::sqrt(n3))));
        current_statement__ = 42;
        lp_accum__.add(
          stan::math::normal_lpdf<false>(d4,
            stan::math::add(DeltaCnat, dX4n),
            stan::math::elt_divide(sigSMn, stan::math::sqrt(n4))));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "cmip_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      double sigXMa = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      sigXMa = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                 0, lp__);
      double sigXMn = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 2;
      sigXMn = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                 0, lp__);
      double sigSMa = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 3;
      sigSMa = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                 0, lp__);
      double sigSMn = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 4;
      sigSMn = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                 0, lp__);
      double DeltaCant = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 5;
      DeltaCant = in__.template read<local_scalar_t__>();
      double DeltaCnat = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 6;
      DeltaCnat = in__.template read<local_scalar_t__>();
      double GRDeltaCant = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 7;
      GRDeltaCant = in__.template read<local_scalar_t__>();
      Eigen::Matrix<double, -1, 1> dX1a_a =
         Eigen::Matrix<double, -1, 1>::Constant(N1a,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 8;
      dX1a_a = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                 N1a);
      Eigen::Matrix<double, -1, 1> dX1n_a =
         Eigen::Matrix<double, -1, 1>::Constant(N1a,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 9;
      dX1n_a = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                 N1a);
      Eigen::Matrix<double, -1, 1> dX1a_b =
         Eigen::Matrix<double, -1, 1>::Constant(N1b,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 10;
      dX1a_b = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                 N1b);
      Eigen::Matrix<double, -1, 1> dX1n_b =
         Eigen::Matrix<double, -1, 1>::Constant(N1b,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 11;
      dX1n_b = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                 N1b);
      Eigen::Matrix<double, -1, 1> dX2a_a =
         Eigen::Matrix<double, -1, 1>::Constant(N2a,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 12;
      dX2a_a = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                 N2a);
      Eigen::Matrix<double, -1, 1> dX2n_a =
         Eigen::Matrix<double, -1, 1>::Constant(N2a,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 13;
      dX2n_a = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                 N2a);
      Eigen::Matrix<double, -1, 1> dX2a_b =
         Eigen::Matrix<double, -1, 1>::Constant(N2b,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 14;
      dX2a_b = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                 N2b);
      Eigen::Matrix<double, -1, 1> dX2n_b =
         Eigen::Matrix<double, -1, 1>::Constant(N2b,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 15;
      dX2n_b = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                 N2b);
      Eigen::Matrix<double, -1, 1> dX3a =
         Eigen::Matrix<double, -1, 1>::Constant(N3,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 16;
      dX3a = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(N3);
      Eigen::Matrix<double, -1, 1> dX4n =
         Eigen::Matrix<double, -1, 1>::Constant(N4,
           std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 17;
      dX4n = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(N4);
      out__.write(sigXMa);
      out__.write(sigXMn);
      out__.write(sigSMa);
      out__.write(sigSMn);
      out__.write(DeltaCant);
      out__.write(DeltaCnat);
      out__.write(GRDeltaCant);
      out__.write(dX1a_a);
      out__.write(dX1n_a);
      out__.write(dX1a_b);
      out__.write(dX1n_b);
      out__.write(dX2a_a);
      out__.write(dX2n_a);
      out__.write(dX2a_b);
      out__.write(dX2n_b);
      out__.write(dX3a);
      out__.write(dX4n);
      if (stan::math::logical_negation((stan::math::primitive_value(
            emit_transformed_parameters__) || stan::math::primitive_value(
            emit_generated_quantities__)))) {
        return ;
      } 
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(VecVar& params_r__, VecI& params_i__,
                                   VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ sigXMa = DUMMY_VAR__;
      sigXMa = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, sigXMa);
      local_scalar_t__ sigXMn = DUMMY_VAR__;
      sigXMn = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, sigXMn);
      local_scalar_t__ sigSMa = DUMMY_VAR__;
      sigSMa = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, sigSMa);
      local_scalar_t__ sigSMn = DUMMY_VAR__;
      sigSMn = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, sigSMn);
      local_scalar_t__ DeltaCant = DUMMY_VAR__;
      DeltaCant = in__.read<local_scalar_t__>();
      out__.write(DeltaCant);
      local_scalar_t__ DeltaCnat = DUMMY_VAR__;
      DeltaCnat = in__.read<local_scalar_t__>();
      out__.write(DeltaCnat);
      local_scalar_t__ GRDeltaCant = DUMMY_VAR__;
      GRDeltaCant = in__.read<local_scalar_t__>();
      out__.write(GRDeltaCant);
      Eigen::Matrix<local_scalar_t__, -1, 1> dX1a_a =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N1a, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= N1a; ++sym1__) {
        stan::model::assign(dX1a_a, in__.read<local_scalar_t__>(),
          "assigning variable dX1a_a", stan::model::index_uni(sym1__));
      }
      out__.write(dX1a_a);
      Eigen::Matrix<local_scalar_t__, -1, 1> dX1n_a =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N1a, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= N1a; ++sym1__) {
        stan::model::assign(dX1n_a, in__.read<local_scalar_t__>(),
          "assigning variable dX1n_a", stan::model::index_uni(sym1__));
      }
      out__.write(dX1n_a);
      Eigen::Matrix<local_scalar_t__, -1, 1> dX1a_b =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N1b, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= N1b; ++sym1__) {
        stan::model::assign(dX1a_b, in__.read<local_scalar_t__>(),
          "assigning variable dX1a_b", stan::model::index_uni(sym1__));
      }
      out__.write(dX1a_b);
      Eigen::Matrix<local_scalar_t__, -1, 1> dX1n_b =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N1b, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= N1b; ++sym1__) {
        stan::model::assign(dX1n_b, in__.read<local_scalar_t__>(),
          "assigning variable dX1n_b", stan::model::index_uni(sym1__));
      }
      out__.write(dX1n_b);
      Eigen::Matrix<local_scalar_t__, -1, 1> dX2a_a =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N2a, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= N2a; ++sym1__) {
        stan::model::assign(dX2a_a, in__.read<local_scalar_t__>(),
          "assigning variable dX2a_a", stan::model::index_uni(sym1__));
      }
      out__.write(dX2a_a);
      Eigen::Matrix<local_scalar_t__, -1, 1> dX2n_a =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N2a, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= N2a; ++sym1__) {
        stan::model::assign(dX2n_a, in__.read<local_scalar_t__>(),
          "assigning variable dX2n_a", stan::model::index_uni(sym1__));
      }
      out__.write(dX2n_a);
      Eigen::Matrix<local_scalar_t__, -1, 1> dX2a_b =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N2b, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= N2b; ++sym1__) {
        stan::model::assign(dX2a_b, in__.read<local_scalar_t__>(),
          "assigning variable dX2a_b", stan::model::index_uni(sym1__));
      }
      out__.write(dX2a_b);
      Eigen::Matrix<local_scalar_t__, -1, 1> dX2n_b =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N2b, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= N2b; ++sym1__) {
        stan::model::assign(dX2n_b, in__.read<local_scalar_t__>(),
          "assigning variable dX2n_b", stan::model::index_uni(sym1__));
      }
      out__.write(dX2n_b);
      Eigen::Matrix<local_scalar_t__, -1, 1> dX3a =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N3, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= N3; ++sym1__) {
        stan::model::assign(dX3a, in__.read<local_scalar_t__>(),
          "assigning variable dX3a", stan::model::index_uni(sym1__));
      }
      out__.write(dX3a);
      Eigen::Matrix<local_scalar_t__, -1, 1> dX4n =
         Eigen::Matrix<local_scalar_t__, -1, 1>::Constant(N4, DUMMY_VAR__);
      for (int sym1__ = 1; sym1__ <= N4; ++sym1__) {
        stan::model::assign(dX4n, in__.read<local_scalar_t__>(),
          "assigning variable dX4n", stan::model::index_uni(sym1__));
      }
      out__.write(dX4n);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"sigXMa", "sigXMn", "sigSMa",
      "sigSMn", "DeltaCant", "DeltaCnat", "GRDeltaCant", "dX1a_a", "dX1n_a",
      "dX1a_b", "dX1n_b", "dX2a_a", "dX2n_a", "dX2a_b", "dX2n_b", "dX3a",
      "dX4n"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
      std::vector<size_t>{}, std::vector<size_t>{}, std::vector<size_t>{
      }, std::vector<size_t>{}, std::vector<size_t>{}, std::vector<size_t>{
      }, std::vector<size_t>{static_cast<size_t>(N1a)},
      std::vector<size_t>{static_cast<size_t>(N1a)},
      std::vector<size_t>{static_cast<size_t>(N1b)},
      std::vector<size_t>{static_cast<size_t>(N1b)},
      std::vector<size_t>{static_cast<size_t>(N2a)},
      std::vector<size_t>{static_cast<size_t>(N2a)},
      std::vector<size_t>{static_cast<size_t>(N2b)},
      std::vector<size_t>{static_cast<size_t>(N2b)},
      std::vector<size_t>{static_cast<size_t>(N3)},
      std::vector<size_t>{static_cast<size_t>(N4)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "sigXMa");
    param_names__.emplace_back(std::string() + "sigXMn");
    param_names__.emplace_back(std::string() + "sigSMa");
    param_names__.emplace_back(std::string() + "sigSMn");
    param_names__.emplace_back(std::string() + "DeltaCant");
    param_names__.emplace_back(std::string() + "DeltaCnat");
    param_names__.emplace_back(std::string() + "GRDeltaCant");
    for (int sym1__ = 1; sym1__ <= N1a; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "dX1a_a" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N1a; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "dX1n_a" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N1b; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "dX1a_b" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N1b; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "dX1n_b" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N2a; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "dX2a_a" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N2a; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "dX2n_a" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N2b; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "dX2a_b" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N2b; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "dX2n_b" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N3; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "dX3a" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N4; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "dX4n" + '.' + std::to_string(sym1__));
      } 
    }
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "sigXMa");
    param_names__.emplace_back(std::string() + "sigXMn");
    param_names__.emplace_back(std::string() + "sigSMa");
    param_names__.emplace_back(std::string() + "sigSMn");
    param_names__.emplace_back(std::string() + "DeltaCant");
    param_names__.emplace_back(std::string() + "DeltaCnat");
    param_names__.emplace_back(std::string() + "GRDeltaCant");
    for (int sym1__ = 1; sym1__ <= N1a; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "dX1a_a" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N1a; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "dX1n_a" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N1b; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "dX1a_b" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N1b; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "dX1n_b" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N2a; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "dX2a_a" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N2a; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "dX2n_a" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N2b; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "dX2a_b" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N2b; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "dX2n_b" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N3; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "dX3a" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= N4; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "dX4n" + '.' + std::to_string(sym1__));
      } 
    }
    if (emit_transformed_parameters__) {
      
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"sigXMa\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigXMn\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigSMa\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigSMn\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"DeltaCant\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"DeltaCnat\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"GRDeltaCant\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"dX1a_a\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N1a) + "},\"block\":\"parameters\"},{\"name\":\"dX1n_a\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N1a) + "},\"block\":\"parameters\"},{\"name\":\"dX1a_b\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N1b) + "},\"block\":\"parameters\"},{\"name\":\"dX1n_b\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N1b) + "},\"block\":\"parameters\"},{\"name\":\"dX2a_a\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N2a) + "},\"block\":\"parameters\"},{\"name\":\"dX2n_a\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N2a) + "},\"block\":\"parameters\"},{\"name\":\"dX2a_b\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N2b) + "},\"block\":\"parameters\"},{\"name\":\"dX2n_b\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N2b) + "},\"block\":\"parameters\"},{\"name\":\"dX3a\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N3) + "},\"block\":\"parameters\"},{\"name\":\"dX4n\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N4) + "},\"block\":\"parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"sigXMa\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigXMn\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigSMa\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"sigSMn\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"DeltaCant\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"DeltaCnat\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"GRDeltaCant\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"dX1a_a\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N1a) + "},\"block\":\"parameters\"},{\"name\":\"dX1n_a\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N1a) + "},\"block\":\"parameters\"},{\"name\":\"dX1a_b\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N1b) + "},\"block\":\"parameters\"},{\"name\":\"dX1n_b\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N1b) + "},\"block\":\"parameters\"},{\"name\":\"dX2a_a\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N2a) + "},\"block\":\"parameters\"},{\"name\":\"dX2n_a\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N2a) + "},\"block\":\"parameters\"},{\"name\":\"dX2a_b\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N2b) + "},\"block\":\"parameters\"},{\"name\":\"dX2n_b\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N2b) + "},\"block\":\"parameters\"},{\"name\":\"dX3a\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N3) + "},\"block\":\"parameters\"},{\"name\":\"dX4n\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(N4) + "},\"block\":\"parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((((((((((((((((1 + 1) + 1) + 1) + 1) + 1) + 1) + N1a) + N1a) + N1b) + N1b)
         + N2a) + N2a) + N2b) + N2b) + N3) + N4);
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      std::vector<double> vars_vec(num_params__
       + (emit_transformed_parameters * num_transformed)
       + (emit_generated_quantities * num_gen_quantities));
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      const size_t num_params__ = 
  ((((((((((((((((1 + 1) + 1) + 1) + 1) + 1) + 1) + N1a) + N1a) + N1b) + N1b)
         + N2a) + N2a) + N2b) + N2b) + N3) + N4);
      const size_t num_transformed = 0;
      const size_t num_gen_quantities = 0;
      vars.resize(num_params__
        + (emit_transformed_parameters * num_transformed)
        + (emit_generated_quantities * num_gen_quantities));
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }

  inline void transform_inits(const stan::io::var_context& context,
                              std::vector<int>& params_i,
                              std::vector<double>& vars,
                              std::ostream* pstream__ = nullptr) const {
     constexpr std::array<const char*, 17> names__{"sigXMa", "sigXMn",
      "sigSMa", "sigSMn", "DeltaCant", "DeltaCnat", "GRDeltaCant", "dX1a_a",
      "dX1n_a", "dX1a_b", "dX1n_b", "dX2a_a", "dX2n_a", "dX2a_b", "dX2n_b",
      "dX3a", "dX4n"};
      const std::array<Eigen::Index, 17> constrain_param_sizes__{1, 1, 
       1, 1, 1, 1, 1, N1a, N1a, N1b, N1b, N2a, N2a, N2b, N2b, N3, N4};
      const auto num_constrained_params__ = std::accumulate(
        constrain_param_sizes__.begin(), constrain_param_sizes__.end(), 0);
    
     std::vector<double> params_r_flat__(num_constrained_params__);
     Eigen::Index size_iter__ = 0;
     Eigen::Index flat_iter__ = 0;
     for (auto&& param_name__ : names__) {
       const auto param_vec__ = context.vals_r(param_name__);
       for (Eigen::Index i = 0; i < constrain_param_sizes__[size_iter__]; ++i) {
         params_r_flat__[flat_iter__] = param_vec__[i];
         ++flat_iter__;
       }
       ++size_iter__;
     }
     vars.resize(num_params_r__);
     transform_inits_impl(params_r_flat__, params_i, vars, pstream__);
    } // transform_inits() 
     }; } using stan_model = cmip_model_namespace::cmip_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return cmip_model_namespace::profiles__;
}

#endif


